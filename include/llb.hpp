#ifndef LLB_HPP
#define LLB_HPP

#include <algorithm>
#include <cassert>
#include <structs.hpp>

class LLB {
 public:
  // Constructor
  LLB() = default;

  static void update_bounds(std::vector<RefPoint> &bounds, Solution &solution, bool validate = false) {
    if (validate) {
      auto local_bounds_naive = bounds;
      auto local_bounds_improved = bounds;
      update_bounds_naive(local_bounds_naive, solution);
      update_bounds_article(local_bounds_improved, solution);
      if (local_bounds_naive.size() != local_bounds_improved.size()) {
        std::cout << "Error: The number of bounds is different in the naive and improved implementations" << std::endl;
        std::cout << "Naive: " << local_bounds_naive.size() << std::endl;
        for (const auto &bound : local_bounds_naive) {
          std::cout << bound.to_string() << std::endl;
        }
        std::cout << "Improved: " << local_bounds_improved.size() << std::endl;
        for (const auto &bound : local_bounds_improved) {
          std::cout << bound.to_string() << std::endl;
        }
        exit(1);
      }
      std::sort(local_bounds_naive.begin(), local_bounds_naive.end(), sort_coordinates);
      std::sort(local_bounds_improved.begin(), local_bounds_improved.end(), sort_coordinates);
      bool wrong_bounds = false;
      for (size_t i = 0; i < local_bounds_naive.size(); ++i) {
        if (local_bounds_naive[i].coordinates != local_bounds_improved[i].coordinates) {
          std::cout << "Error: The bounds are different in the naive and improved implementations" << std::endl;
          std::cout << "Naive: " << local_bounds_naive[i].to_string() << std::endl;
          std::cout << "Improved: " << local_bounds_improved[i].to_string() << std::endl;
          wrong_bounds = true;
        }
      }
      if (wrong_bounds) {
        exit(1);
      }
    }
    update_bounds_article(bounds, solution);
  }

  // Get dominated bounds
  static std::vector<RefPoint> get_dominated_bounds(const std::vector<RefPoint> &bounds, const Solution &sol) {
    std::vector<RefPoint> dominated_bounds;
    for (const auto &bound : bounds) {
      if (strongly_dominates(sol.coordinates, bound.coordinates)) {
        dominated_bounds.push_back(bound);
      }
    }
    return dominated_bounds;
  }

  // Get dominated bounds
  static std::vector<int32_t> get_dominated_bounds_idx(const std::vector<RefPoint> &bounds, const Solution &sol) {
    std::vector<int32_t> dominated_bounds;
    for (int i = 0; i < (int)bounds.size(); i++) {
      if (strongly_dominates(sol.coordinates, bounds[i].coordinates)) {
        dominated_bounds.push_back(i);
      }
    }
    return dominated_bounds;
  }

 private:
  // Vector v1 weakly dominates vector v2 if v1[i] >= v2[i] for all i.
  static bool weakly_dominates(const std::vector<int64_t> &v1, const std::vector<int64_t> &v2) {
    for (size_t i = 0; i < v1.size(); ++i) {
      if (v1[i] < v2[i]) return false;
    }
    return true;
  }

  // Vector v1 strongly dominates vector v2 if v1[i] > v2[i] for all i.
  static bool strongly_dominates(const std::vector<int64_t> &v1, const std::vector<int64_t> &v2) {
    for (size_t i = 0; i < v1.size(); ++i) {
      if (v1[i] <= v2[i]) return false;
    }
    return true;
  }

  // Sort coordinates
  static bool sort_coordinates(const RefPoint &a, const RefPoint &b) {
    assert(a.coordinates.size() == b.coordinates.size());
    return a.id < b.id;
    // for (size_t i = 0; i < a.coordinates.size(); ++i) {
    //   if (a.coordinates[i] < b.coordinates[i]) return true;
    //   if (a.coordinates[i] > b.coordinates[i]) return false;
    // }
    // return false;
  }

  static std::vector<RefPoint> create_bounds(const RefPoint &ref, const Solution &sol) {
    std::vector<RefPoint> bounds;
    if (!strongly_dominates(sol.coordinates, ref.coordinates)) {
      return bounds;
    }
    // Verify if the reference point coordinates vector is the same size as the solution coordinates vector.
    assert(ref.coordinates.size() == sol.coordinates.size());
    // The total number of bounds generated is equal to the coordinates vector size, that is, the number of dimensions
    // The bounds are generated by replacing each coordinate of the reference point with the corresponding coordinate of the solution
    int32_t dimensions = ref.coordinates.size();
    // Generate the bounds
    for (int32_t i = 0; i < dimensions; i++) {
      // Special case: the reference point is the first reference point (u0)
      std::string bound_id = ref.id + std::to_string(i + 1);
      RefPoint new_bound = RefPoint(bound_id, ref.coordinates, ref.defining_points);
      new_bound.coordinates[i] = sol.coordinates[i];
      new_bound.defining_points[i] = sol.id;
      bounds.push_back(new_bound);
    }
    return bounds;
  }

  static void update_bounds_naive(std::vector<RefPoint> &bounds, const Solution &sol) {
    // Steps of the naive implementation
    // 1. Compute the strongly dominated bounds
    // 2. Create the new bounds generated by each dominated bound
    // 3. Remove the dominated bounds from the bounds vector
    // 4. Remove redundant new bounds from the new bounds vector
    // 5. Remove redundant new bounds from the bounds vector
    // 6. Add the new bounds to the bounds vector

    // Step 1:
    std::vector<RefPoint> dominated_bounds = std::vector<RefPoint>();
    std::vector<int32_t> dominated_bounds_idx = std::vector<int32_t>();
    for (int i = 0; i < (int)bounds.size(); i++) {
      if (strongly_dominates(sol.coordinates, bounds[i].coordinates)) {
        dominated_bounds.push_back(bounds[i]);
        dominated_bounds_idx.push_back(i);
      }
    }
    if (dominated_bounds.empty()) return;
    // std::cout << "Step 1: " << dominated_bounds.size() << std::endl;
    // Step 2:
    std::vector<RefPoint> new_bounds = std::vector<RefPoint>();
    for (auto &bound : dominated_bounds) {
      std::vector<RefPoint> aux_bounds = create_bounds(bound, sol);
      new_bounds.insert(new_bounds.end(), aux_bounds.begin(), aux_bounds.end());
    }
    // std::cout << "Step 2: " << new_bounds.size() << std::endl;
    // // DEBUG: Print the new bounds
    // sort(new_bounds.begin(), new_bounds.end(), sort_coordinates);
    // std::cout << "Naive - New bounds:" << std::endl;
    // for (auto &bound : new_bounds) {
    //   std::cout << bound.to_string() << std::endl;
    // }
    // Step 3:
    for (auto it = dominated_bounds_idx.rbegin(); it != dominated_bounds_idx.rend(); it++) {
      std::swap(bounds[*it], bounds.back());
      bounds.pop_back();
    }
    // std::cout << "Step 3: " << bounds.size() << std::endl;
    // Step 4:
    std::vector<int32_t> redundant_bounds_idx = std::vector<int32_t>();
    for (int i = 0; i < (int)new_bounds.size(); i++) {
      for (int j = i + 1; j < (int)new_bounds.size(); j++) {
        // We keep the "smallest" llb's while removing redundant "larger" llb's
        // Note: It is the other way around for minimization problems!
        if (weakly_dominates(new_bounds[i].coordinates, new_bounds[j].coordinates)) {
          redundant_bounds_idx.push_back(i);
          // std::cout << "Bound " << new_bounds[i].to_string() << " is weakly dominated by " << new_bounds[j].to_string() << std::endl;
        } else if (weakly_dominates(new_bounds[j].coordinates, new_bounds[i].coordinates)) {
          redundant_bounds_idx.push_back(j);
          // std::cout << "Bound " << new_bounds[j].to_string() << " is weakly dominated by " << new_bounds[i].to_string() << std::endl;
        }
      }
    }
    // std::cout << "Step 4: " << redundant_bounds_idx.size() << std::endl;
    // Sort and remove duplicates, then start removing from the end of the vector
    std::sort(redundant_bounds_idx.begin(), redundant_bounds_idx.end());
    redundant_bounds_idx.erase(std::unique(redundant_bounds_idx.begin(), redundant_bounds_idx.end()), redundant_bounds_idx.end());
    for (auto it = redundant_bounds_idx.rbegin(); it != redundant_bounds_idx.rend(); ++it) {
      std::swap(new_bounds[*it], new_bounds.back());
      new_bounds.pop_back();
    }
    // std::cout << "Step 4: " << new_bounds.size() << std::endl;
    // Step 5:
    redundant_bounds_idx.clear();
    for (int j = 0; j < (int)bounds.size(); j++) {
      for (int i = 0; i < (int)new_bounds.size(); i++) {
        if (weakly_dominates(new_bounds[i].coordinates, bounds[j].coordinates)) {
          redundant_bounds_idx.push_back(i);
          // std::cout << "Bound " << bounds[j].to_string() << " is weakly dominated by " << new_bounds[i].to_string() << std::endl;
        }
      }
    }
    // std::cout << "Step 5: " << redundant_bounds_idx.size() << std::endl;
    // Sort and remove duplicates, then start removing from the end of the vector
    std::sort(redundant_bounds_idx.begin(), redundant_bounds_idx.end());
    redundant_bounds_idx.erase(std::unique(redundant_bounds_idx.begin(), redundant_bounds_idx.end()), redundant_bounds_idx.end());
    for (auto it = redundant_bounds_idx.rbegin(); it != redundant_bounds_idx.rend(); ++it) {
      std::swap(new_bounds[*it], new_bounds.back());
      new_bounds.pop_back();
    }
    // Step 6:
    bounds.insert(bounds.end(), new_bounds.begin(), new_bounds.end());
    // std::cout << "Step 6: " << bounds.size() << std::endl;
  }

  // Algorithm 3 from the paper "On the representation of the search region in multi-objective optimization"
  // (http://dx.doi.org/10.1016/j.ejor.2015.03.031)
  static void update_bounds_article(std::vector<RefPoint> &bounds, Solution &sol) {
    int32_t dimensions = sol.coordinates.size();
    // Steps of Algorithm 3
    // 1. Find the bounds that are strongly dominated by the solution (A)
    // 2. Find the bounds that are weakly dominated at each dimension by the solution (B)
    // 3. Generate candidate bounds for each strongly dominated bound (P)
    // 4. Filter redundant candidate bounds with bounds at step 2
    // 5. Remove dominated bounds from the bounds vector
    // 6. Add the candidate bounds to the bounds vector
    // 7. Return the new bounds vector

    // Step 1:
    std::vector<RefPoint> A;
    std::vector<int64_t> A_idx;
    for (int i = 0; i < (int)bounds.size(); i++) {
      if (strongly_dominates(sol.coordinates, bounds[i].coordinates)) {
        A.push_back(bounds[i]);
        A_idx.push_back(i);
      }
    }
    if (A.empty()) return;
    // Step 2:
    // Vector of bounds with the same coordinates as z at each dimension.
    std::vector<std::vector<RefPoint>> B(dimensions, std::vector<RefPoint>());
    for (int j = 0; j < dimensions; j++) {
      for (const auto &bound : bounds) {
        if (sol.coordinates[j] == bound.coordinates[j]) {
          bool is_dominated = false;
          for (int k = 0; k < dimensions; k++) {
            if (k != j) {
              if (sol.coordinates[k] < bound.coordinates[k]) {
                is_dominated = true;
                break;
              }
            }
          }
          if (!is_dominated) {
            B[j].push_back(bound);
          }
        }
      }
    }
    // Step 3:
    // Vector of candidate bounds for each strongly dominated bound.
    std::vector<std::vector<RefPoint>> P(dimensions, std::vector<RefPoint>());
    for (const auto &bound : A) {
      for (int i = 0; i < dimensions; i++) {
        std::string bound_id = bound.id + std::to_string(i + 1);
        RefPoint new_bound = RefPoint(bound_id, bound.coordinates, bound.defining_points);
        new_bound.coordinates[i] = sol.coordinates[i];
        new_bound.defining_points[i] = sol.id;
        P[i].push_back(new_bound);
      }
    }
    // std::cout << "\nAlgorithm - Candidate bounds:" << std::endl;
    // for (int i = 0; i < dimensions; i++) {
    //   // sort(P[i].begin(), P[i].end(), sortCoordinates);
    //   // std::cout << "Dimension " << i << ":" << std::endl;
    //   for (auto &bound : P[i]) {
    //     std::cout << bound.to_string() << std::endl;
    //   }
    // }
    // Step 4:
    for (int j = 0; j < dimensions; j++) {
      std::vector<RefPoint> filtered_bounds;
      for (const auto &p : P[j]) {
        bool is_dominated = false;
        for (const auto &u : P[j]) {
          if (u.id != p.id && weakly_dominates(p.coordinates, u.coordinates)) {
            is_dominated = true;
            break;
          }
        }
        for (const auto &b : B[j]) {
          if (weakly_dominates(p.coordinates, b.coordinates)) {
            is_dominated = true;
            break;
          }
        }
        if (!is_dominated) {
          filtered_bounds.push_back(p);
        }
      }
      P[j] = filtered_bounds;
    }
    // Step 5:
    for (auto it = A_idx.rbegin(); it != A_idx.rend(); ++it) {
      // std::cout << "Removing dominated bound: " << bounds[*it].to_string() << std::endl;
      std::swap(bounds[*it], bounds.back());
      bounds.pop_back();
    }
    // Step 6:
    for (int i = 0; i < dimensions; i++) {
      bounds.insert(bounds.end(), P[i].begin(), P[i].end());
    }
  }
};

#endif  // LLB_HPP
